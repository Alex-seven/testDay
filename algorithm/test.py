
'''
题目1：
		实现求一个1000位数字组成的数中
		连续13位数乘积最大的序列及其乘积
'''
def a():
	str_a = '''
	73167176531330624919225119674426574742355349194934
	96983520312774506326239578318016984801869478851843
	85861560789112949495459501737958331952853208805511
	12540698747158523863050715693290963295227443043557
	66896648950445244523161731856403098711121722383113
	62229893423380308135336276614282806444486645238749
	30358907296290491560440772390713810515859307960866
	70172427121883998797908792274921901699720888093776
	65727333001053367881220235421809751254540594752243
	52584907711670556013604839586446706324415722155397
	53697817977846174064955149290862569321978468622482
	83972241375657056057490261407972968652414535100474
	82166370484403199890008895243450658541227588666881
	16427171479924442928230863465674813919123162824586
	17866458359124566529476545682848912883142607690042
	24219022671055626321111109370544217506941658960408
	07198403850962455444362981230987879927244284909188
	84580156166097919133875499200524063689912560717606
	05886116467109405077541002256983155200055935729725
	71636269561882670428252483600823257530420752963450
	'''
	import re
	str_a = re.sub('\n','',str_a)
	result =[]
	x = 0 
	while x < len(str_a) - 11:
		l = str_a[x:x+13]
		y = 0
		
		if '0' not in l:  # 跳过包含0的
			z = 1
			while y < len(l):
				z *= int(l[y])
				y += 1
			result.append(z)
		x += 1
	print(max(result))


'''
题目2：
		一个毕达哥拉斯三元组是一个包含三个自然数的集合，a < b < c，满足条件：

		a2 + b2 = c2


		例如：32 + 42 = 9 + 16 = 25 = 52。

		已知存在并且只存在一个毕达哥拉斯三元组满足条件 a + b + c = 1000。

		找出该三元组中 abc 的乘积。
'''
def b1():
	x = 1
	while x < 1000:
		y = x + 1
		while y < 1000:
			z = 1000 - x -y
			if x**2 + y**2 == z**2 :	
				print('x:%d\ny:%d\nz:%d'%(x,y,z))
				print('x*x:%d  ; y*y:%d ; z*z:%d'%(x**2,y**2,z**2))
				print('x + y + z == %s'%(x + y + z))
				print('x*y*z=%d'%(x*y*z))
			y += 1
		x += 1

def b2():
	for a in range(1000):
		for b in range(a,1000):
			c = 1000 - a- b
			if a*a+b*b == c*c and c>b:
				print (a*b*c)

'''
	题目：计算两百万以下所有质数的和
'''

# isfrime 已经过多次调整，现只适合用于 run3()
def isfrime(x):
	# if x == 2:
	# 	return True
	for k in range(2,x):
		if x % k == 0:
			return False
	return True

def run():
	result = 0
	i = 2
	while i < 2000000:
		if isfrime(i):
			result += i
		i += 1
	print(result)

def run2():
	result = 0
	for i in range(2,2000001):
		if isfrime(i):
			result += i
	print(result)

def run3():
	print(2 + sum([i for i in range(3,2000000,2) if isfrime(i)]))

'''
	getPrime : (原理)
 			用的是标记法，先建一个列表，列表的项数等于要求的最大质数，内容都为True。
			然后第0,1项设为False，因为0和1都不是质数。
			从第2项开始，是2的倍数的项都是设为假，因为都不是质数。
			然后只要是列表内还没有设为假的数，从它开始，它的倍数都设为假，直到列表内全部为真的数，那就是质数。
			原理就是这样。
			利用列表的项数和列表值的对应关系。这样可以减少判断次数，当然速度就是最快的了。
'''
def run4(n):
        primes = [True]*n
        primes[0],primes[1]=False,False
        for (i, prime) in enumerate(primes):
                if prime:
                        for j in range(i*i,n,i): primes[j] = False
        return [k for (k,trueprime) in enumerate(primes) if trueprime]

# print (sum(run4(2000000)))

if __name__ == "__main__":
	import time
	t1 = time.time()
	# run()
	run3()

	t2 = time.time()
	print(t2 - t1)

